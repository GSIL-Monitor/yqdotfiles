/* eslint  max-len:["off"] no-constant-condition:["off"] import/extensions:["off"] */
/* global THREE */

// demo: http://115.28.35.140/main-page/lmv/58002f35d1a49d7b9322fce4

import CombinedCamera from './vendor/threejs/CombinedCamera';
import OrbitControlsExt from './vendor/threejs/OrbitControlsExt';
import EffectComposer from './vendor/threejs/postprocessing/EffectComposer';
import FilmPass from './vendor/threejs/postprocessing/FilmPass';
import MaskPass from './vendor/threejs/postprocessing/MaskPass';
import RenderPass from './vendor/threejs/postprocessing/RenderPass';
import ShaderPass from './vendor/threejs/postprocessing/ShaderPass';
import UnrealBloomPass from './vendor/threejs/postprocessing/UnrealBloomPass';
import ConvolutionShader from './vendor/threejs/shaders/ConvolutionShader';
import CopyShader from './vendor/threejs/shaders/CopyShader';
import DotScreenShader from './vendor/threejs/shaders/DotScreenShader';
import FilmShader from './vendor/threejs/shaders/FilmShader';
import FXAAShader from './vendor/threejs/shaders/FXAAShader';
import LuminosityHighPassShader from './vendor/threejs/shaders/LuminosityHighPassShader';
import cursorDefault from './vendor/assets/cursorDefault.png';
import cursorPan from './vendor/assets/cursorPan.png';
import cursorZoom from './vendor/assets/cursorZoom.png';
import ErrorHandler from '../../toolKit/ErrorHandler.js';
import Node from './Node.js';
import FirstPersonControls from './vendor/threejs/FirstPersonControls.js';

class GbimViewer {
  /**
   * GBim viewer.
   * @param {DOM/string} container Container the viewer will be embeded in;
   * @param {Object/Json} params Parameters.
   * @param {csscolor} params.background Background of the viewer.
   * @param {boolean} params.transparent Background transparent or not.
   * @param {number} params.distance Initial distance by scene radius times. 1 for nearest, etc. Default 3.
   * @param {number} params.autoRotateSpeed Initial auto rotate speed of camera. Default 0.1.
   * @param {object} params.effects Effects.
   * @param {boolean} params.FXAA = true FXAA effect, default true.
   * @param {boolean} params.effects.bloom Bloom.effect, default false.
   * @param {boolean} params.effects.film Film effect, default false.
   */
  constructor(container, params) {
    if (params.distance === undefined) params.distance = 3;
    if (params.autoRotateSpeed === undefined) params.autoRotateSpeed = 0.1;
    if (params.effects === undefined) params.effects = {};
    if (params.effects.FXAA === undefined) params.effects.FXAA = true;

    this.params = params;

    this.container = typeof container === 'string' ? document.getElementById(container) : container;

    this.scene = new THREE.Scene();
    this.nodeState = {
      isolatedNodes: {},
      highlightedNodes: {},
      hiddenNodes: {},
      translucencyNode: {},
    };

    const ambientLight = new THREE.AmbientLight(0x999999);
    this.scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0x333333);
    directionalLight.position.set(1, 1, 1);
    this.scene.add(directionalLight);

    this.cameraNear = 0.01;
    const rect = this.container.getBoundingClientRect();

    this.camera = new THREE.CombinedCamera(rect.width, rect.height, 30, this.cameraNear, 1000, -500, 1000);
    this.camera.position.set(100, 100, 100);
    this.scene.add(this.camera);
    this.camera.lookAt(this.scene.position);

    const pointLight = new THREE.PointLight(0x333333);
    this.camera.add(pointLight);

    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(rect.width, rect.height);
    this.container.appendChild(this.renderer.domElement);

    // PostProcessing
    this.composer = new THREE.EffectComposer(this.renderer);

    const renderPass = new THREE.RenderPass(this.scene, this.camera);
    renderPass.renderToScreen = true;
    this.composer.addPass(renderPass);

    if (params.effects.FXAA) {
      /* eslint func-names:['off'] */
      const effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
      effectFXAA.uniforms.resolution.value.set(1 / rect.width, 1 / rect.height);
      effectFXAA.setSize = function (width, height) {
        this.uniforms.resolution.value.set(1 / width, 1 / height);
      };

      this.composer.addPass(effectFXAA);
    }

    if (params.effects.bloom) {
      const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(rect.width, rect.height), 0.3, 0.4, 0.9);
      this.composer.addPass(bloomPass);
    }

    if (params.effects.film) {
      const effectFilm = new THREE.FilmPass(0.15, 0.1, 1000, false);
      this.composer.addPass(effectFilm);
    }

    const copyPass = new THREE.ShaderPass(THREE.CopyShader);
    copyPass.renderToScreen = true;
    this.composer.addPass(copyPass);

    if (params.background !== undefined) this.setBackground(params.background);
    if (params.transparent !== undefined) this.setTransparent(params.transparent);

    this.controls = new THREE.OrbitControls(this.camera, this.container);
    this.controls.zoomSpeed = 0.3;
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.1;
    this.controls.rotateSpeed = 0.1;
    this.controls.autoRotate = true;
    this.controls.autoRotateSpeed = params.autoRotateSpeed;

    this.camControls = new THREE.FirstPersonControls(this.camera);
    this.camControls.lookSpeed = 0.04;
    this.camControls.movementSpeed = 2;
    this.camControls.noFly = true;
    this.camControls.lookVertical = true;
    this.camControls.constrainVertical = true;
    this.camControls.lon = 0;
    this.camControls.lat = 0;
    this.camControls.enabled = true;

    const clock = new THREE.Clock();
    const _this = this;

    function animate() {
      requestAnimationFrame(animate);

      if (_this.controls.enabled) {
        _this.controls.update();
      } else {
        const delta = clock.getDelta();
        _this.camControls.update(delta);
      }
      _this.render();
    }

    animate();

    window.addEventListener('resize', () => {
      const rect = _this.container.getBoundingClientRect();

      _this.camera.setSize(rect.width, rect.height);
      _this.camera.updateProjectionMatrix();

      _this.renderer.setSize(rect.width, rect.height);
      _this.composer.setSize(rect.width, rect.height);
    }, false);

    const cursorDefaultStyle = `url("${cursorDefault}"), default`;
    const cursorPanStyle = `url("${cursorPan}'"), default'`;
    const cursorZoomStyle = `url("'${cursorZoom}"), default`;
    this.controls.addEventListener('change', () => {
      _this.render();
    });

    let dampingStartTimer;

    this.controls.addEventListener('start', () => {
      if (dampingStartTimer) {
        window.clearTimeout(dampingStartTimer);
        dampingStartTimer = null;
      }

      _this.controls.autoRotate = false;

      switch (_this.controls.getState()) {
      case _this.controls.mouseButtons.PAN:
        _this.container.style.cursor = cursorPanStyle;
      break;
      case _this.controls.mouseButtons.ZOOM:
        _this.container.style.cursor = cursorZoomStyle;
      break;
      default:
        _this.container.style.cursor = cursorDefaultStyle;
    }
    });

    const startDamping = () => {
      window.clearTimeout(dampingStartTimer);
      dampingStartTimer = null;

      _this.controls.autoRotate = true;
    };

    this.controls.addEventListener('end', () => {
      _this.container.style.cursor = cursorDefaultStyle;

      dampingStartTimer = window.setTimeout(startDamping, 2000);
    });
    _this.container.style.cursor = cursorDefaultStyle;

    _this.render();

    this.dispatchEvent({ type: 'gBimViewerLoaded', gBimViewer: this, });
    return this;
  }

  render() {
    this.composer.render();
  }

  /**
   * Toggle camera betweem perspective mode and orthographic mode.
   * @param toPerspective
   * @warn Camera distance need fixing.
   */
  toggleCamera(toPerspective) {
    if (toPerspective === undefined) toPerspective = true;

    if (toPerspective) this.camera.toPerspective();
    else this.camera.toOrthographic();
    this.render();
  }

  /**
   * 统一NodeUUID的形式, 将输入的str, obj, arr形式的NodeUUID全部转换为obj索引, 如果需要在建立索引时验证nodeUUID的合法性, 给GbimViewer.checkNodeUUID赋值一个函数, 其参数为{String} nodeUUID.
   * @param {String/Object/Array} nodeUUID nodeUUID可以是三种形式
   * @param {Function} callback 应用输出的索引表
   * @throws {Error}
   */
  static formatNodeUUID(nodeUUID, callback) {
    const elemObj = {};
    if (!callback) {
      ErrorHandler.throw('callback is necessary');
    }

    let checkNodeUUID;
    if (GbimViewer.checkNodeUUID) {
      checkNodeUUID = GbimViewer.checkNodeUUID;
    }

    if (typeof nodeUUID === 'string') {
      if (checkNodeUUID && !checkNodeUUID(nodeUUID)) return;
      elemObj[nodeUUID] = nodeUUID;
    } else if (Object.prototype.toString.call(nodeUUID).slice(8, -1) === 'Array' && nodeUUID.length) {
      nodeUUID.forEach(id => {
        if (checkNodeUUID && !checkNodeUUID(id)) return;
        elemObj[id] = id;
      });
    } else if (Object.prototype.toString.call(nodeUUID).slice(8, -1) === 'Object' && Object.keys(nodeUUID).length) {
      Object.keys(nodeUUID).forEach(id => {
        if (checkNodeUUID && !checkNodeUUID(id)) return;
        elemObj[id] = id;
      });
    }

    callback(elemObj);
  }

  /**
   * 根据 documentId 和 nodeUUID 获取 Node 节点。
   * @param {String} nodeUUID 节点ID
   * @param {Object} node uuid的索引表
   * @returns {BIMSDK.Node} 返回查找到的节点
   */
  getNode(nodeUUID, filterElemList) {
    let _filterElemList = filterElemList;
    if (filterElemList === undefined) {
      if (this.hasOwnProperty('_allElements')) {
        _filterElemList = this._allElements;
      } else {
        ErrorHandler.throw('need to give a filter list of nodes');
        return false;
      }
    }

    return new Node(_filterElemList[nodeUUID]); // this.allElements包含的是obj3d中的node
  }

  /**
   * 对所有节点执行处理函数。
   * @param {function(Node)} callback 回调函数。
   * @returns {XiheMap.Node} 返回查找到的节点
   */
  eachNode(callback, filterElemList) {
    let _filterElemList = filterElemList;
    if (filterElemList === undefined) {
      if (this.hasOwnProperty('_allElements')) {
        _filterElemList = this._allElements;
      } else {
        ErrorHandler.throw('need to give a filter list of nodes');
        return false;
      }
    }

    Object.keys(_filterElemList).forEach((node) => {
      if (Node.idOfThreejsNode(_filterElemList[node])) {
        if (callback) callback(new Node(_filterElemList[node]));
      }
    });
  }

  /**
   * 根据节点属性设置节点外观。
   * @param {string} documentId 文档ID。
   * @param {json} props 要筛选的属性组合，如 {level:1, type:'door'} 。
   * @param {json} nodeVisuals 要设置的外观属性组合，支持 visible、highlight、translucency 。外观属性支持函数，格式为 function(Node) 。
   * @returns {XiheMap.Node} 返回查找到的节点
   */
  filterNode(props, nodeVisuals) {
    this.eachNode((node) => {
        let propsMatch = true;
        if (props) {
          Object.keys(props).some((p) => {
            // 如果props是函数, 通过函数判断, 如果不是, 则认为props是一个Node实例, 直接比较给予的Node的每个参数是否与node相同
            if (typeof props[p] === 'function' ? props[p](node) : node[p] !== props[p]) {
              propsMatch = false;
              return false;
            }

            return true;
          });
        }

        if (propsMatch !== false && nodeVisuals) {
          Object.keys(nodeVisuals).forEach((v) => {
            const vv = nodeVisuals[v];
            node[v] = typeof vv === 'function' ? vv(node) : vv;
          });
        }
      });
  }

  /**
   * 根据 nodeUUID 孤立或恢复 Node 节点。
   * @param {String/Array/Object} nodeUUID 要孤立的节点ID。
   * @param {boolean} isolate true=孤立(默认) false=恢复
   */
  isolateNodes(nodeUUID, isolate = true) {
    GbimViewer.formatNodeUUID(nodeUUID, (elemObj) => {
      this.filterNode({ parm: (node) => {
          if (node.id && !elemObj[node.id]) {
            node.translucency = isolate;
            if (!isolate && this.nodeState.isolatedNodes[node.id]) {
              delete this.nodeState.isolatedNodes[node.id];
            } else {
              this.nodeState.isolatedNodes[node.id] = node.id;
            }

            return true;
          }
        }, }, null);
    });

    this.nodeState.isolating = true;
  }

  getIsolatedNodes() {
    return this.nodeState.isolatedNodes;
  }

  setIsolatedNodes(nodeUUID, isolate = true) {
    this.isolateNodes(nodeUUID, isolate);
  }

  /**
   * 根据 nodeUUID 显示或隐藏 Node 节点。
   * @param {String|Array|Object} nodeUUID 节点的ID
   * @param {boolean} show true=显示 false=隐藏(默认)
   * @returns {XiheMap.Node} 返回对应的节点
   */
  showNode(nodeUUID, show = false) {
    GbimViewer.formatNodeUUID(nodeUUID, (elemObj) => {
      Object.keys(elemObj).forEach(id => {
        this.getNode(id).show = show;
        if (show && this.nodeState.hiddenNodes[id]) {
          delete this.nodeState.hiddenNodes[id];
        } else {
          this.nodeState.hiddenNodes[id] = id;
        }
      });
      this.nodeState.isHidden = true;
    });
  }

  /**
   * 根据 nodeUUID 高亮或恢复 Node 节点。
   * @param {String|Array|Object} nodeUUID 节点的ID
   * @param {boolean} show true=高亮(默认) false=恢复
   * @returns {Node} 返回对应的节点
   */
  highlightNode(nodeUUID, highlight = true) {
    GbimViewer.formatNodeUUID(nodeUUID, (elemObj) => {
      Object.keys(elemObj).forEach(id => {
        this.getNode(id).highlight = highlight;
        if (!highlight && this.nodeState.highlightedNodes[id]) {
          delete this.nodeState.highlightedNodes[id];
        } else {
          this.nodeState.highlightedNodes[id] = id;
        }
      });
      this.nodeState.highlighting = true;
    });
  }

  /**
   * 根据 nodeName 半透明或恢复 Node 节点。
   * @param {String|Array|Object} nodeUUID 节点的ID
   * @param {boolean} show true=半透明(默认) false=恢复
   * @returns {XiheMap.Node} 返回对应的节点
   */
  translucencyNode(nodeUUID, translucency = true) {
    GbimViewer.formatNodeUUID(nodeUUID, (elemObj) => {
      Object.keys(elemObj).forEach(id => {
        this.getNode(id).translucency = translucency;
        if (!translucency && this.nodeState.translucencyNode[id]) {
          delete this.nodeState.translucencyNode[id];
        } else {
          this.nodeState.translucencyNode[id] = id;
        }
      });
      this.nodeState.istranslucency = true;
    });
  }

  /**
   * Set the background of the viewer.
   * @param {csscolor} background The background of the viewer will be set.
   * @param {number} alpha Alpha of background.
   */
  setBackground(background, alpha) {
    this.renderer.setClearColor(background, alpha);
    this.render();
  }

  /**
   * Set transparency of background.
   * @param {boolean} transparent Set whether the background will be transparent or not. When set, background property will be ignored.
   */
  setTransparent(transparent) {
    this.renderer.setClearAlpha(transparent ? 0 : 1);
    this.render();
  }

  /**
   * 获取视图信息数据
   * @returns {object}
   */
  getViewInfo() {
    const viewInfo = {
      matrix: this.camera.matrix.toArray(),
      position: this.camera.position.toArray(),
      target: this.controls.target.toArray(),
    };
    return viewInfo;
  }

  /**
   * 设置视图信息数据
   * @param {object} viewInfo
   */
  setViewInfo(viewInfo) {
    if (viewInfo) {
      this.camera.matrix.fromArray(viewInfo.matrix);
      this.camera.matrix.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
      this.controls.target.fromArray(viewInfo.target);
    }
  }

  /**
   * 获取渲染快照。
   * @returns {string/base64/imageURL}
   */
  snapshot() {
    this.render();
    return this.renderer.domElement.toDataURL();
  }

  /**
   * 清理内存
   *
   * @access public
   * @param {Object} obj THREE.Object3D
   */
  dispose(obj) {
    const children = obj.children;
    if (children) {
      for (let i = 0; i < children.length; i += 1) {
        this.dispose(children[i]);
      }
    }

    const geometry = obj.geometry;
    const material = obj.material;
    if (geometry) {
      geometry.dispose();
    }

    if (material) {
      const texture = material.map;
      if (texture) {
        texture.dispose();
      }

      material.dispose();
    }
  }

  disposeScene() {
    if (this.hasOwnProperty('scene')) {
      this.dispose(this.scene);
    }
  }

  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return;

    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== undefined) {
      event.target = this;

      const array = [];
      let i = 0;
      const length = listenerArray.length;

      /* eslint no-plusplus:['off'] */
      for (i = 0; i < length; i++) {
        array[i] = listenerArray[i];
      }

      for (i = 0; i < length; i++) {
        array[i].call(this, event);
      }
    }
  }
/*
 *set Path
 * vertices is vec3 point Array 
 * as: [[0,0,0],[0,1,1],[0,2,1]] 
 */

addPathToViewWithArray(vertices) {
  const paths = new THREE.Group();
  const material = new THREE.MeshBasicMaterial({ color: 0x008800 });
  let i = 1;
  for (i = 1; i < vertices.length; i += 1) {
    const v0 = vertices[i - 1];
    const v1 = vertices[i];
    const distance = v1.distanceTo(v0);
    const lineGeometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 4, 1, false);
    const matrix1 = new THREE.Matrix4();
    matrix1.makeTranslation(0, distance / 2, 0);
    lineGeometry.applyMatrix(matrix1);
    const matrix2 = new THREE.Matrix4();
    matrix2.makeRotationX(Math.PI / 2);
    lineGeometry.applyMatrix(matrix2);
    const mesh = new THREE.Mesh(lineGeometry, material);
    mesh.position.copy(v0);
    mesh.lookAt(v1);
    paths.add(mesh);
  }
  this.scene.add(paths);
}
/*
 * change to user firstperson gesture
 * true is to change first person
 */
changeUserFirstPersonGesture (isEnable) {
  if (isEnable) {
    this.camControls.target = this.controls.target;

    var target = this.controls.target;
    var position = this.camera.position;
    var distance = Math.sqrt(Math.pow(target.x - position.x , 2) + Math.pow(target.y - position.y , 2) + Math.pow(target.z - position.z,2)) ;

    var phi = Math.acos((target.y - position.y) / distance);
    var theta = Math.acos(((target.x - position.x) / (Math.sin(phi) * distance))) ;
    var theta =  Math.asin(((target.z - position.z) / (Math.sin(phi) * distance)));

    var lat =90 - THREE.Math.radToDeg(phi);
    lat = Math.max( - 85, Math.min( 85, lat ) );
    var lon = THREE.Math.radToDeg(theta);

    this.camControls.lat = lat;
    this.camControls.lon = lon;

    this.camControls.enabled = true;
    this.camControls.addAllEventListeners();

    this.controls.enabled = false;
    this.controls.autoRotate = false;

    this.controls.dispose();

  } else {
    this.controls.target = this.camControls.target;
    this.camControls.enabled = false;
    this.camControls.dispose();

    this.controls.enabled = true;
    this.controls.autoRotate = true;
    this.controls.addAllEventListeners();
  }
}

}

// 检查NodeUUID合法性的函数, 参数为nodeUUID, 自动使用 应让用户自己在传入前检查
GbimViewer.checkNodeUUID = null;

window.GbimViewer = GbimViewer;
export default GbimViewer;
